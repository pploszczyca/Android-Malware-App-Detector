from abc import ABC
import time
from contextlib import contextmanager

from sklearn.metrics import accuracy_score, confusion_matrix, classification_report


class Classifier(ABC):
    def __init__(self, training_data, test_data, name):
        self.name = name
        self.X_train = training_data.drop('Label', axis=1)
        self.y_train = training_data['Label']
        self.X_test = test_data.drop('Label', axis=1)
        self.y_test = test_data['Label']
        self.model = None
        self.grid_search = None

    def train_and_evaluate(self):
        if self.grid_search is not None:
            self.grid_search.fit(self.X_train, self.y_train)
            self.model = self.grid_search.best_estimator_
            self.__print_best_params()
        else:
            self.model.fit(self.X_train, self.y_train)

    def __print_best_params(self):
        if self.grid_search:
            print(f"Best Parameters for {self.name}: {self.grid_search.best_params_}")

    def print_statistics(self):
        self.__print_model_statistics(self.X_test, self.y_test)
        print("\n")
        self.__test_and_print_time_of_prediction()
        print("\n")

    def __print_model_statistics(self, x_data, y_data):
        predictions = self.model.predict(x_data)
        accuracy = accuracy_score(y_data, predictions)
        confusion = confusion_matrix(y_data, predictions)
        report = classification_report(y_data, predictions)

        print(f"Classifier: {self.name}")
        print(f"Accuracy: {accuracy}")
        print(f"Confusion Matrix:\n{confusion}")
        print(f"Classification Report:\n{report}")

    def __test_and_print_time_of_prediction(self):
        sizes = [0.1, 0.5, 1.0]

        print(f"Time for prediction for {self.name} model:")
        for size in sizes:
            with self.__measure_time(size):
                X_sample_test = self.__get_sample(self.X_test, size)
                self.model.predict(X_sample_test)

    @staticmethod
    @contextmanager
    def __measure_time(size: int):
        start = time.perf_counter()
        yield
        end = time.perf_counter()
        elapsed_time = end - start
        print(f"Time for size {size}: {elapsed_time:.6f} seconds")

    @staticmethod
    def __get_sample(data, size):
        sample_size = int(len(data) * size)
        return data[:sample_size]
